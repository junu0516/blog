

+++

title = "스위프트 클로저 개념 정리"
tags = ["swift"]
categories = ["Swift&Ios"]
date = "2022-01-15"

+++

​    

자바를 사용하다가 스위프트를 사용하면서 체감하는 제일 큰 차이는 함수형 프로그래밍의 사용인 것 같다. 자바에서도 스트림으로 함수형 프로그래밍을 사용할 수 있지만 여전히 자바는 객체지향 언어로 쓰이는 것이 정석이다 보니 함수형 프로그래밍에 대해 이전까지는 제대로 알지 못했다. 스위프트를 사용하다보면 함수형으로 작성되어 {} 코드 블록을 인자로 넘기는 경우를 심심치 않게 보게 되는데 이를 클로저라고 부른다.



스위프트에서 함수형 프로그래밍 패러다임을 이해하기 위해  클로저(Closure)를 이해하는 것은 첫걸음이자 필수이다. 따라서 이번에는 클로저의 개념과 사용에 대해 정리해보았다.

​    

<img src="https://camo.githubusercontent.com/073d4db3e63450a4287978fd866b98ab9816dd2040cb87ef5395ec5a2f9a732e/68747470733a2f2f7377696674756e626f7865642e636f6d2f696d616765732f636c6f737572652d6573636170652e706e67" alt="image" style="zoom:35%"/>    

​    

## 1. 클로저 개념

스위프트에서 클로저는 {} 코드블록이 객체처럼 전달되면서 사용되는 독립적인 블록이다. 쉽게 말해 __이름이 없는 함수__ 의 형태라고 생각하면 된다. 따라서 함수는 __`func`__ 키워드가 붙은 클로저의 한 형태라 할 수 있다.

​    

클로저는 아래와 같이 세 가지 형태로 나눠볼 수 있다.

- 이름이 있지만, 값을 획득하지 않는 형태(전역 함수)

```swift
func print() {
  print("Hello")
} 	
```

- 내부 함수와 같이 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 형태(중첩 합수)

```swift
func outer(){
  func print(_ name: String) {
    print("Hello \(name)")
  }
  var name: String = "Jed"
  print(name)
}
```

- 이름이 없고 주변 문맥에 따라 값을 획득하는 형태(축약 형태)

```swift
let num: Int = {return 0}
```

​    

위의 세 가지 예시처럼 클로저는 함수처럼 쓰이거나, 객체처럼 다른 변수에 할당할 수 있다. 스위프트에서 **함수는 1급 객체로 할당 받기, 인자로 전달하기, 반환하기 등이 모두 가능하다.** 스위프트에서 함수는 이름 없는 클로저이기 때문에, 결과적으로 클로저 역시 1급 객체이며 상수나 변수에 할당되거나 저장해서 사용 가능하다.

​    

## 2. 기본적인 클로저 사용

바로 위에서 클로저를 다른 상수에 할당했기 때문에 여기서는 클로저를 함수의 인자로 전달하는 예를 살펴보도록 한다.

​    

스위프트에서 배열은 기본적으로 __`sort()`__ 라는 정렬 함수를 제공한다. 해당 함수에 아무런 인자를 전달하지 않으면 배열은 오름차순으로 정렬되며, 다른 기준으로 정렬하고자 할 경우에는 원하는 기준을 함수의 인자로 전달하면 된다. 

바로 여기서 별도의 정렬 기준을 전달할 때 이를 클로저 형식으로 전달할 수 있다.

```swift
var arr: [Int] = [1,3,2,5,4]
```

위와 같은 정수 배열에서 __`arr.sort()`__ 를 실행하면 배열이 [1,2,3,4,5]로 자동 정렬될 것이다.

이를 별도의 정렬 기준을 전달해서 내림차순으로 바꾸고 싶다면 아래와 같이 작성하면 된다. 여기서 인자로 넘긴 __`{return $0>$1}`__ 은 $0이 $1보다 큰 지 여부를 Bool 타입으로 리턴하는 클로저이다. 

```swift
//내림차순 정렬
arr.sort(by:{return $0>$1})
```

