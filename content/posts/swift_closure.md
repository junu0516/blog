

+++

title = "스위프트 클로저 개념 정리(작성중)"
tags = ["swift"]
categories = ["Swift&Ios"]
date = "2022-01-15"

+++

​    

자바를 사용하다가 스위프트를 사용하면서 체감하는 제일 큰 차이는 함수형 프로그래밍의 사용인 것 같다. 자바에서도 스트림으로 함수형 프로그래밍을 사용할 수 있지만 여전히 자바는 객체지향 언어로 쓰이는 것이 정석이다 보니 함수형 프로그래밍에 대해 이전까지는 제대로 알지 못했다. 스위프트를 사용하다보면 함수형으로 작성되어 {} 코드 블록을 인자로 넘기는 경우를 심심치 않게 보게 되는데 이를 클로저라고 부른다.



스위프트에서 함수형 프로그래밍 패러다임을 이해하기 위해  클로저(Closure)를 이해하는 것은 첫걸음이자 필수이다. 따라서 이번에는 클로저의 개념과 사용에 대해 정리해보았다.

​    

<img src="https://camo.githubusercontent.com/073d4db3e63450a4287978fd866b98ab9816dd2040cb87ef5395ec5a2f9a732e/68747470733a2f2f7377696674756e626f7865642e636f6d2f696d616765732f636c6f737572652d6573636170652e706e67" alt="image" style="zoom:33%"/>    

​    

## 1. 클로저 개념

스위프트에서 클로저는 {} 코드블록이 객체처럼 전달되면서 사용되는 독립적인 블록이다. 쉽게 말해 __이름이 없는 함수__ 의 형태라고 생각하면 된다. 따라서 함수는 __`func`__ 키워드가 붙은 클로저의 한 형태라 할 수 있다.

​    

클로저는 아래와 같이 세 가지 형태로 나눠볼 수 있다.

- 이름이 있지만, 값을 획득하지 않는 형태(전역 함수)

```swift
func print() {
  print("Hello")
} 	
```

- 내부 함수와 같이 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 형태(중첩 합수)

```swift
func outer(){
  func print(_ name: String) {
    print("Hello \(name)")
  }
  var name: String = "Jed"
  print(name)
}
```

- 이름이 없고 주변 문맥에 따라 값을 획득하는 형태(축약 형태)

```swift
let num: Int = {return 0}
```

​    

위의 세 가지 예시처럼 클로저는 함수처럼 쓰이거나, 객체처럼 다른 변수에 할당할 수 있다. 스위프트에서 **함수는 1급 객체로 할당 받기, 인자로 전달하기, 반환하기 등이 모두 가능하다.** 스위프트에서 함수는 이름 없는 클로저이기 때문에, 결과적으로 클로저 역시 1급 객체이며 상수나 변수에 할당되거나 저장해서 사용 가능하다.

​    

## 2. 클로저 사용하기

### 2-1. 기본적인 클로저 사용하기

우선, 클로저의 표현은 기본적으로 아래의 형식을 따른다.

```swift
{
  (매개변수) -> 리턴타입 in
  	실행코드 + 리턴
}
```

매개변수와 리턴타입, 코드가 존재한다는 점에서 함수와 비슷한 형식이며 __`in`__ 은 실행 코드와 매개변수+리턴타입 선언부의 분리를 위한 것이다.

​    

바로 위에서 클로저를 다른 상수에 할당했기 때문에 여기서는 클로저를 함수의 인자로 전달하는 예를 살펴보도록 한다.    

스위프트에서 배열은 기본적으로 __`sort()`__ 라는 정렬 함수를 제공한다. 해당 함수에 아무런 인자를 전달하지 않으면 배열은 오름차순으로 정렬되며, 다른 기준으로 정렬하고자 할 경우에는 원하는 기준을 함수의 인자로 전달하면 된다. 

바로 여기서 별도의 정렬 기준을 전달할 때 이를 클로저 형식으로 전달할 수 있다.

```swift
var arr: [Int] = [1,3,2,5,4]
```

위와 같은 정수 배열에서 __`arr.sort()`__ 를 실행하면 배열이 [1,2,3,4,5]로 자동 정렬될 것이다.

이를 별도의 정렬 기준을 전달해서 내림차순으로 바꾸고 싶다면 아래와 같이 작성하면 된다. 여기서 인자로 넘긴 __`{return $0>$1}`__ 은 $0이 $1보다 큰 지 여부를 Bool 타입으로 리턴하는 클로저이다. 

```swift
//내림차순 정렬
arr.sort(by:{return $0>$1})   
```

애플의 [공식 문서](https://developer.apple.com/documentation/swift/array/2296801-sort)를 보면 __`sort()`__ 의 정의를 아래와 같이 설명하고 있다.

```swift
mutating func sort(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows
```

여기서 파라미터의 타입으로 __`(Element, Element) throws -> Bool`__ 이 선언된 것을 볼 수 있는데, 이는 2개의 인자를 받아 Bool 타입을 리턴하는 클로저를 해당 함수가 인자(by)로 받음을 의미한다. 클로저가 함수의 인자로 전달되는 대표적인 예인 것이다.

​    

### 2-2. 후행 클로저 사용하기

스위프트에서는 __`후행 클로저(Trailing Closure)`__ 를 사용할 수 있다. 함수의 마지막 인자에 클로저가 위치할 때, 소괄호를 닫은 후 클로저를 작성해도 되는 것인데 클로저의 길이가 길거나 괄호 안에 모든 인자를 명시하기에 가독성이 떨어진다 싶을 때 유용하다.

위의 __`sort()`__ 의 인자로 클로저를 넘길 때, 후행 클로저를 사용하면 아래와 같이 코드를 작성할 수 있다.

```swift
//기본 클로저
arr.sort(by:{return $0>$1})

//후행 클로저
arr.sort(){return $0>$1}
```

또한, 하나의 클로저만 인자로 전달할 경우에는 함수의 소괄호를 생략해도 된다.

```swift
arr.sort{$0>$1}
```

​    

주의할 점은 후행 클로저로 사용 가능한 클로저는 __전달인자의 맨 마지막에 위치한 것들만 가능하다는 점이다.__ 따라서 여러 개의 클로저를 인자로 전달할 경우에는 맨 마지막 클로저만 후행 클로저 형식으로 사용할 수 있다.

아래와 같이 클로저를 인자로 받는 함수가 존재한다고 가정해보자.

```swift
func calculate(_ a: Int, _ b: Int, _ increment:(Int, Int)-> Int,  _ subtract: (Int, Int) -> Int) -> Int {
  let left = increment(a,b)
  let right = subtract(a,b)
  return left+right
}

var result = calculate(1,2,{$0+$1},{$0-$1})
print(result)
//2
```

​    

### 2-3. 클로저를 간단하게 표현하기

​    

## Reference

- 스위프트 프로그래밍: Swift 5(3판) - 야곰, 한빛미디어
- [Swift) 클로저(Closure) 정복하기(1/3) - 클로저, 누구냐 넌](https://babbab2.tistory.com/81)

- 
